# How to Utilize Cursor and Claude to Get Shit Done

This guide is for **developers** joining the project who are new to agentic AI tools (Cursor, Claude Code, etc.). It covers how to get the most out of these tools, set guardrails, and use tokens and context efficiently so you build strong, repeatable workflows.

---

## Before You Start: Orienting the Agent

### Use .cursorignore and .cursorindexignore to Limit Scope

Create a `.cursorignore` file in your project root to exclude folders like `node_modules/`, `.vscode/`, `dist/`, and log files. This prevents Claude from scanning irrelevant files and reduces token use. You can mirror `.gitignore` rules to DRY up your config.

For example:
```bash
node_modules/
dist/
.vscode/
*.log
```

Use `.cursorindexignore` to prevent Claude from even suggesting or indexing certain files in the UI. Great for large schema files, archives, or autogenerated code.

Agents perform best when they know *where* to look and *what* rules apply. A few habits pay off immediately.

### Point the agent at the right docs

- **Project context:** Our agent reads `CLAUDE.md` for project overview, roadmap, repo structure, and conventions. For Crucible, it also knows about `README.md`, `concept.md`, and `docs/` (see `INDEX.md` for the full doc map).
- **Current work:** When working on a sprint or feature, **@-mention** the relevant plan or spec (e.g. `@docs/plans/sprints/04-sprint-3-frontend-animations.md`) so the agent stays in scope.

### When to @-mention vs paste

- **@-mention files/folders** when you want the agent to read and respect their contents (e.g. a sprint plan, a component, or `CLAUDE.md`). The agent can then reference them in context.
- **Paste short snippets** when you need a one-off answer about a specific line or error; keeps context smaller.

### One run, one job

- Give **one clear task per conversation or Composer run** (e.g. “Add mobile submenu to the match header” instead of “Fix header parity”). This keeps scope bounded and token use predictable.

---

## Understanding Token & Context Usage

Context is everything the model “sees”: your message, attached files, and prior turns. More context = more tokens = higher cost and slower responses. Use it wisely.

### What helps agents most

- **Relevant files only:** Attach or @-mention the files (or folders) the agent needs to edit or read. Avoid “read the whole repo.”
- **Explicit constraints:** “Only edit `apps/web/app/page.tsx`” or “Do not change any API routes” focus the agent and cut down exploratory reads.
- **Short, clear instructions:** One paragraph with task + allowed files + “done when X” is better than a long essay.

### What burns tokens without much gain

- **Open-ended verification:** “Check all pages for design consistency” or “Verify parity” has no clear stopping point; the agent may keep scanning.
- **Epic-sized tasks:** “Fix frontend parity” or “Clean up CSS everywhere” imply many files and many steps; break them into smaller tickets.
- **Re-reading the same big doc** in every run; have the agent read a spec once, then give small tickets that reference it.

---

## Chunking and Scoping (Why Small Tasks Win)

Agents behave like very careful junior engineers: they will read more than you expect and keep going unless you set limits. **Small, bounded tasks** give predictable runs and fewer token blowups.

### One task, one outcome

- **Good:** “Remove the BACK TO SITE link from the match header.” “Add a 10% chance to stay at lowest rarity in `determineCraftedRarity`.”
- **Bad:** “Fix the header.” “Improve crafting.”

Aim for **1–3 concrete, related changes per run**. If you have more, split into separate tasks or tickets. This is good for quick stuff, but for bigger chunks of work, break features and whatnot down into tickets with a spec document and have Claude tackle a group of tickets in order. I usually have it handle 3-10 tickets at once, but try not to go higher than that top limit. 

### Separate “rules” from “work”

- **Specs / guidelines** = rules, constraints, design intent. They are **read-only context** (e.g. design-guidelines.md, a sprint plan). The agent *follows* them. Within each spec document you'll have files to reference and files the agent is allowed to edit. More on this later.
- **Tickets / tasks** = the actual work. The agent *does* exactly what the ticket says, within the spec.

Don’t ask the agent to “do everything in the spec.” Ask it to “follow the spec while completing this ticket.”


---

## Models

Different models have different tradeoffs. Use the right one for the job.

### When to use which

- **Sonnet (e.g. Claude Sonnet):** Best default for **implementation** — fast and token-efficient for coding. Prefer this for most edits and multi-file changes.
- **Opus (e.g. Claude Opus, especially “thinking”):** Use only for **small, curated reasoning** (e.g. one design decision, one tricky algorithm). Do *not* use Opus thinking for repo-wide scans or large refactors; it’s expensive and slow.
- **Cursor:** I just use Auto because I accidentally learned the hard way and used Opus for a bunch of stuff earlier this month lol. So I'm pretty much out of tokens for the month on Cursor, but Cursor has a bunch of model options. 


---

## Skills

Skills are reusable rules or workflows the agent can load (e.g. “using-superpowers,” “frontend-design,” “react-best-practices”). They extend what the agent knows how to do without you rewriting instructions every time.

### How we use them

- **Crucible:** Our agent is told to use skills under `agents/skills/` (or the project’s skill path) when the task involves rules, workflows, or multi-step processes. It starts with the “using-superpowers” (or equivalent) skill to see how to invoke others.
- **In tickets:** You can add a “Mandatory skill usage” section: e.g. “Read the using-superpowers skill first; use frontend-design when designing the treatment.” That way the agent loads the right skills for the task.
- **Path:** I keep my skills folder in @agents/ , maybe just do that

---

## Guidelines and Guardrails for Your Agent

Clear rules reduce back-and-forth and keep the agent from drifting. These are the kinds of guidelines that actually work.

### Allowed Files and Hard Limits

- **Allowed Files:** In a ticket or prompt, list the **exact paths or globs** the agent may edit (e.g. `apps/web/app/match/[matchId]/page.tsx`, `apps/web/components/arena/**`). The agent may *only* edit files in this list.
- **Hard Limits:** State what the agent must *not* do (e.g. “Do not edit static files in `public/`,” “Do not run build or test commands”).
- **If blocked:** Tell the agent: “If the component lives elsewhere, **stop and ask** to extend the Allowed Files list.” That avoids guessing and editing the wrong place.

Our project’s `CLAUDE.md` already tells the agent: do not run build/compile or perform QA; verification is the human’s job. You can reinforce that in your prompts.

### Why this helps

- Prevents scope creep and accidental edits outside the task.
- Cuts token use (no exploratory grep across the whole repo).
- Makes reviews easier (only a few files change).

---

## Cursor-Specific Tips

Cursor gives you several ways to work with the agent; use the right one for the task.

### Composer vs Chat

- **Composer:** Best for **multi-file edits** and implementation. You can attach files, reference the codebase, and get a plan + edits in one run. Use it for “implement this ticket” or “add this feature to these components.”
- **Chat:** Good for **questions, explanations, and small edits**. Use it when you need a quick answer or a single-file change.

### Inline edits (Cmd+K or similar)

- Use for **local, single-file** changes (e.g. “add a null check here,” “rename this variable”). Keeps context small and fast.

### Branches and multi-agent work

- If multiple people (or multiple runs) touch the same area, use **separate branches** or **one writer at a time** to avoid merge conflicts and duplicate work.
- You can organize and assign tickets in a strategic way to ensure tickets are completed in order without prerequisite work being incomplete

---

## When Things Go Wrong

Even with good scoping, sometimes the agent goes off track. Here’s how to recover.

### Agent goes out of scope

- **Stop the run** and narrow the ask. Give a **smaller task** and **Allowed Files** so the next run can’t wander.

### Token limit or endless reads

- **Start a new chat** and give a **single, concrete task** with only the files needed. Avoid re-attaching huge specs every time; reference them by name and let the agent read once.

### Wrong files edited

- **Revert** the changes (git), then re-run with **explicit Allowed Files** and “If the code lives elsewhere, stop and ask.”

### Agent wants to “verify” or “run tests”

- Our project instructs the agent **not** to run build, test, or QA; that’s the human’s job. If the agent offers, you can say “Don’t run any commands; I’ll verify.” This saves tokens and keeps responsibility clear.
- You can make exceptions to this rule when you specify, but tool calls take up token usage more aggressively

---

## Handoffs and Continuity

When the agent finishes a task, a short record helps you and the next dev (or next run).

### Implementation summary

- At the end of a ticket or in a follow-up message, have the agent add (or you add) an **Implementation Summary** with:
  - **Completed:** Ticket ID and short name.
  - **Changes Made:** Numbered list of edits (files, components, key logic).
  - **Files Modified:** Exact paths.
  - **Skills Used:** (if any).
  - **Result:** One-line outcome.
- Summaries live in @docs/plans/summaries/

That way you can see “did we already do this?” and hand off cleanly.



---

## Workflow Examples and Templates

Concrete patterns you can copy and adapt.

### Example 1: Single, bounded code change

**Prompt shape:**

- **Task:** One sentence (e.g. “Add a 10% chance to keep lowest rarity in crafting.”).
- **Reference:** @-mention the relevant file(s) and/or spec (e.g. `@packages/shared/src/crafting/crafting-system.ts`, `@docs/design/design-guidelines.md` if styling).
- **Constraints:** “Only edit `packages/shared/src/crafting/crafting-system.ts`. Do not change API routes or UI.”
- **Done when:** “Function `determineCraftedRarity` implements the new 10% branch and tests (if any) are updated.”


### Example 2: UI change with design rules

**Prompt shape:**

- **Task:** One UI change (e.g. “Move the War Council button below the arena bar, above Admin and Logout.”).
- **Reference:** @-mention the page/component and `@docs/design/design-guidelines.md`.
- **Allowed Files:** List the component(s) and any layout file (e.g. `apps/web/app/page.tsx`, `apps/web/components/...`).
- **Done when:** “Button order matches spec; only listed files modified.”


### Example 3: Ticket-driven run (specs + ticket)

- **Before the run:** You have a spec (e.g. “RPG UI design”) and a ticket (e.g. “07-camp-nav-mobile-submenu”). These specs and tickets can be generated by Cursor according to your plain-language explanation, and when you ask Cursor to generate them, have it reference @claude-workflow-opt.md. 
- **Prompt:** “Follow the rules in @docs/plans/specs/rpg-ui-design.md and complete the task in @docs/plans/tickets/07-camp-nav-mobile-submenu.md. Only edit files listed under Allowed Files in the ticket. If blocked, stop and ask.”

### Ticket template (replaceable)

You can copy this into a ticket file and fill in the bracketed parts:

```markdown
## Task
- [One concrete change, 1–3 related items max]

## Mandatory skill usage
- [e.g. Read using-superpowers first; use frontend-design for this task.]
- [List 2–5 skills that apply.]

## Reference Docs (read-only)
- [e.g. docs/design/design-guidelines.md, docs/plans/sprints/06-sprint-5-progression-loot.md]

## Allowed Files (ONLY these)
- [exact paths or globs, e.g. apps/web/app/camp/page.tsx, apps/web/components/camp/**]
- If the code lives elsewhere, stop and ask to extend this list.

## Hard Limits
- [e.g. Do not edit public/ or contracts/. Do not run build or tests.]
- If blocked: stop and ask; do not guess paths.

## Instructions
1. [Step one]
2. [Step two]
3. [Step three]

## Done Criteria
- [Concrete, verifiable outcome]
- Only listed files modified.
- [Optional: implementation summary added at bottom.]
```

**Replaceable:** [Add your team’s standard ticket path and naming, e.g. `docs/plans/tickets/NN-short-name.md`.]

---

## Project-Specific Conventions (Crucible)

So the agent and new devs stay aligned with this repo.

### Where things live

- **Agent instructions:** `CLAUDE.md` — project overview, roadmap, conventions, “no build/QA,” key docs.
- **Doc index:** `INDEX.md` — non-docs file tree and **documentation index** (all markdown under `docs/` with paths and short descriptions). Use it to find the right doc to @-mention.
- **Plans:** `docs/plans/sprints/` (sprint plans), `docs/plans/summaries/` (what was built), `docs/plans/implementation/` (date-stamped implementation plans).
- **Guides and features:** `docs/guides/`, `docs/features/`, `docs/design/`, `docs/data-glossary.md`, etc. — see `INDEX.md`.

### What the agent is already told (CLAUDE.md)

- Implement only within **demo scope** and the **current (or requested) sprint**. No out-of-scope features (marketplace, gacha, token economics, etc.) unless the task explicitly asks.
- **No review, verification, or QA** by the agent; no build/compile unless you ask. You verify.
- **Server authority:** Match outcomes are server-authoritative; don’t trust client-reported results.
- **Game data:** Follow `docs/data-glossary.md` (§11); no hardcoded slots, no behavior hidden in conditionals, templates define behavior and instances define ownership.

### Replaceable

- [Add: any other repo-specific rules new devs should know when writing prompts or tickets.]
- [Add: link to README “Development” or “Contributing” if you have one.]

---

## Quick Reference Card (Replaceable)

[Add a short table or list your team can copy from, e.g.:]

| Goal | Do this |
|------|--------|
| One code change | One sentence task + Allowed Files + Done when |
| UI + design | @-mention component + design-guidelines + Allowed Files |
| Big feature | Split into tickets; one ticket per run; reference spec |
| Agent off scope | Stop; narrow task; add Allowed Files; new chat if needed |
| After a run | Implementation summary (files, changes, result) |
| Find the right doc | `INDEX.md` → docs layout and quick reference by purpose |

---

## Recommended Tools for Claude + Cursor Efficiency

These optional but powerful tools can drastically reduce token usage and increase iteration speed.

- **GrepAI** – Local semantic code search (massive token savings vs fuzzy scan).
- **Project Rule Files (`.cursor/rules/`)** – Enforce “do not remove comments” or “preserve semicolons” via guardrails Claude will follow.
- **Language Server / Code-Intel Plugins** – Unlocks better “jump to def” and “reference” logic for Claude’s internal nav.

Use sparingly, but deliberately. These don’t add complexity — they reduce friction.
